<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"superzlw.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="写在前面的说明 本文总结自B站博主DR_CAN，他是整个B站我最喜欢的博主没有之一，推荐大家直接去看他的视频，这篇当作学后的回顾，链接在这\(\rightarrow\)【传送门】。">
<meta property="og:type" content="article">
<meta property="og:title" content="卡尔曼滤波（Kalman Filter）">
<meta property="og:url" content="https://superzlw.github.io/posts/20.html">
<meta property="og:site_name" content="SuperZLW&#39;s Blog">
<meta property="og:description" content="写在前面的说明 本文总结自B站博主DR_CAN，他是整个B站我最喜欢的博主没有之一，推荐大家直接去看他的视频，这篇当作学后的回顾，链接在这\(\rightarrow\)【传送门】。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://superzlw.github.io/images/250.png">
<meta property="og:image" content="https://superzlw.github.io/images/271.png">
<meta property="article:published_time" content="2021-08-12T21:50:05.144Z">
<meta property="article:modified_time" content="2021-08-22T14:05:42.331Z">
<meta property="article:author" content="super_wzl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://superzlw.github.io/images/250.png">

<link rel="canonical" href="https://superzlw.github.io/posts/20.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>卡尔曼滤波（Kalman Filter） | SuperZLW's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SuperZLW's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">贩卖咸鱼の海边小店</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://superzlw.github.io/posts/20.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="super_wzl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperZLW's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          卡尔曼滤波（Kalman Filter）
        </h1>

        <div class="post-meta">
          <span class="post-time">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 23:50:05" itemprop="dateCreated datePublished" datetime="2021-08-12T23:50:05+02:00">2021-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-22 16:05:42" itemprop="dateModified" datetime="2021-08-22T16:05:42+02:00">2021-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/20.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/20.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="写在前面的说明">写在前面的说明</h1>
<p>本文总结自B站博主DR_CAN，他是整个B站我最喜欢的博主没有之一，推荐大家直接去看他的视频，这篇当作学后的回顾，链接在这<span class="math inline">\(\rightarrow\)</span><a target="_blank" rel="noopener" href="https://space.bilibili.com/230105574/channel/detail?cid=139198&amp;ctype=0">【传送门】</a>。 <span id="more"></span></p>
<h1 id="引入-递归算法">引入 —— 递归算法</h1>
<p>卡尔曼滤波器可看作是一种“Optimal Recursive Data Processing Algorithm”，即“最优的递归数字处理算法”。与滤波器相比它更像是一种观测器。<br />
卡尔曼滤波器的应用非常广泛，尤其是导航中，这是因为现实生活中充满大量的不确定性，当我们描述一个系统的时候，这个不确定性主要体现在以下三个方面：<br />
</p>
<blockquote>
<ol type="1">
<li>不存在完美的数学模型；<br />
</li>
<li>系统的挠动是不可控的，也很难建模；<br />
</li>
<li>测量传感器存在误差。 </li>
</ol>
</blockquote>
<p>举个例子：<br />
当我们要测量一枚硬币的直径时，设第<span class="math inline">\(k\)</span>次测量结果为<span class="math inline">\(z_k\)</span>，假如三次测量分别为： <span class="math display">\[z_1=50.1mm\]</span> <span class="math display">\[z_2=50.4mm\]</span> <span class="math display">\[z_3=50.2mm\]</span> 若要估计真实数据，很自然地，我们会用平均值来表示，即第<span class="math inline">\(k\)</span>次的估计值<span class="math inline">\(\hat{x}_k\)</span>为：</p>
<p><span class="math display">\[
\begin{split}
\hat{x}_k &amp;= \frac{1}{k}(z_1+...+z_k)\\\\ 
 &amp;= \frac{1}{k}(z_1+...+z_{k-1})+\frac{1}{k}z_k\\\\ &amp;=
\frac{1}{k}\frac{k-1}{k-1}(z_1+...+z_{k-1})+\frac{1}{k}z_k \\\\
&amp;=\frac{k-1}{k}\hat{x}_{k-1}+\frac{1}{k}z_k\\\\
&amp;=\hat{x}_{k-1}-\frac{1}{k}\hat{x}_{k-1}+\frac{1}{k}z_k
\end{split}
\]</span></p>
<p>即是：</p>
<p><span class="math display">\[
\hat{x}_k=\hat{x}_{k-1}+\frac{1}{k}(z_k-\hat{x}_{k-1})
\]</span></p>
<p>由此可见，当<span class="math inline">\(k\)</span>逐渐增加时，<span class="math inline">\(\frac{1}{k}\rightarrow \infty\)</span>，也就是说<span class="math inline">\(\hat{x}_k\rightarrow \hat{x}_{k-1}\)</span>。<br />
用文字描述的话，就是说随着<span class="math inline">\(k\)</span>的增加，之后测量结果也就不再重要了，也就是对前面的真实估计值已经非常有信心了。<br />
相反，当<span class="math inline">\(k\)</span>比较小时，<span class="math inline">\(\frac{1}{k}\)</span>就会很大，也就是说此时<span class="math inline">\(z_k\)</span>的作用会很大。<br />
现在改写一下上面的式子为： <span class="math display">\[
\hat{x}_k=\hat{x}_{k-1}+K_k(z_k-\hat{x}_{k-1})
\]</span> 在卡尔曼滤波器里，这个系数<span class="math inline">\(K_k\)</span>就叫Kalman Gain，中文称为卡尔曼增益/因数。<br />
由这个式子可以看出，跟马尔科夫链类似，当前估计值只与该次测量值以及上一次的估计值有关，这体现了一种递归的思想。<br />
这里先对这个系数作简单的讨论。首先引入两个变量：</p>
<blockquote>
<ol type="1">
<li>估计误差：<span class="math inline">\(e_{EST}\)</span>；<br />
</li>
<li>测量误差：<span class="math inline">\(e_{MEA}\)</span>。</li>
</ol>
</blockquote>
<p>卡尔曼增益就等于： <span class="math display">\[
K_k=\frac{e_{EST_{k-1}}}{e_{EST_{k-1}}+e_{MEA_k}}
\]</span> <strong>这个公式是卡尔曼滤波的核心公式，详细推导见后文。</strong><br />
这里先简单讨论在<span class="math inline">\(k\)</span>时刻两个变量的作用：</p>
<blockquote>
<ol type="1">
<li>当<span class="math inline">\(e_{EST_{k-1}} \gg e_{MEA_k}\)</span>，即<span class="math inline">\(k\rightarrow 1\)</span>时，<span class="math inline">\(\hat{x}_k=\hat{x}_{k-1}+z_k-\hat{x}_{k-1}=z_{k}\)</span>；<br />
</li>
<li>当<span class="math inline">\(e_{EST_{k-1}} \ll e_{MEA_k}\)</span>，即<span class="math inline">\(k\rightarrow 0\)</span>时，<span class="math inline">\(\hat{x}_k=\hat{x}_{k-1}\)</span>。</li>
</ol>
</blockquote>
<p>运用卡尔曼滤波器，真实估计值就可以表示为以下三个步骤：</p>
<blockquote>
<ol type="1">
<li><strong>Step 1</strong>：计算卡尔曼增益：<span class="math inline">\(K_k=\frac{e_{EST_{k-1}}}{e_{EST_{k-1}}+e_{MEA_k}}\)</span>；<br />
</li>
<li><strong>Step 2</strong>：计算当前估计值<span class="math inline">\(\hat{x}_k=\hat{x}_{k-1}+K_k(z_k-\hat{x}_{k-1})\)</span>；</li>
<li><strong>Step 3</strong>：更新<span class="math inline">\(e_{EST_k}=(1-K_k)e_{EST_{k-1}}\)</span>（这个式子后面推导）。</li>
</ol>
</blockquote>
<p>这里举个例子说明上面三个步骤：<br />
假设我们要测量一个长度是<span class="math inline">\(50mm\)</span>的物体，第0次的估计值，也就是相当于先验吧，是<span class="math inline">\(\hat{x}_0=40mm\)</span>，第0次估计误差为<span class="math inline">\(e_{EST_0}=5mm\)</span>，第一次测量为<span class="math inline">\(z_1=51mm\)</span>，测量误差一直为<span class="math inline">\(e_{MEA_k}=3mm\)</span>。<br />
填入起始值，如下表：<br />
</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(z_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(e_{MEA_k}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\hat{x}_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(K_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(e_{EST_k}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">40</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">51</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>借助上面三个步骤：<br />
<span class="math inline">\(k=1\)</span>时： <span class="math display">\[
K_k=\frac{5}{5+3}=0.625
\]</span> <span class="math display">\[
\hat{x}_k=40+0.625(51-40)=46.875
\]</span> <span class="math display">\[
e_{EST}=(1-0.625)\times 5 = 1.875
\]</span> 然后<span class="math inline">\(k=2\)</span>时，设此次测量值为<span class="math inline">\(z_2=48\)</span>，重复上面的步骤，就可以填满表格了。如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(z_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(e_{MEA_k}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\hat{x}_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(K_k\)</span></th>
<th style="text-align: center;"><span class="math inline">\(e_{EST_k}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">40</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">51</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">46.88</td>
<td style="text-align: center;">0.625</td>
<td style="text-align: center;">1.875</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;">48</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">47.31</td>
<td style="text-align: center;">0.385</td>
<td style="text-align: center;">1.154</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">47</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">47.22</td>
<td style="text-align: center;">0.278</td>
<td style="text-align: center;">0.833</td>
</tr>
</tbody>
</table>
<p>这样不断下去，最后这个真实估计值会收敛于<span class="math inline">\(50mm\)</span>。<br />
借用博主视频里的数值结果图片，其表现如下： <img src="/images/250.png" /> 其中蓝色线表示测量值，红色线表示估计值。</p>
<h1 id="数据融合协方差矩阵状态空间方程">数据融合，协方差矩阵，状态空间方程</h1>
<p>这部分是复习基础知识，可跳过。</p>
<h2 id="数据融合">数据融合</h2>
<p>简单讲，就是从多个测量数据中找到一个最优的。<br />
举个例子，我们在称量一个物体的时候，两次称量结果如下： <span class="math display">\[
z_1=30g, \quad \sigma_1=2g
\]</span> <span class="math display">\[
z_2=32g, \quad \sigma_2=4g
\]</span> 根据正态分布的性质，对于第一个测量结果，真实值落在区间[28,32]的概率是68.4%；对第二个测量结果，真实值落在区间[28,36]的概率是68.4%，如果这时候要我们估计真实值的话，我们会把真实值估计在区间[30,32]之间，而且由于第一个测量标准差较小，所以真实值会更靠近于30。<br />
如果要我们在数学上得到一个比较准确的值，就可以用上面递归的方法，写出如下等式： <span class="math display">\[
\hat{z}=z_1+K(z_2-z_1)
\]</span> 其中 <span class="math inline">\(K\in [0,1]\)</span>，当<span class="math inline">\(K=0\)</span>时，<span class="math inline">\(\hat{z}=z_1\)</span>；当<span class="math inline">\(K=1\)</span>时，<span class="math inline">\(\hat{z}=z_2\)</span>。<br />
现在我们要求<span class="math inline">\(K\)</span>，使得 <span class="math inline">\(\sigma_{\hat{z}}\)</span> 最小，即是要 <span class="math inline">\(Var(\hat{z})\)</span> 最小。<br />
而这个方差我们可以写成： <span class="math display">\[
\sigma_{\hat{z}}^2=Var(z_1+K(z_2-z_1))=Var((1-K)z_1+Kz_2)
\]</span> 由于括号里的两项 <span class="math inline">\((1-K)z_1\)</span> 和 <span class="math inline">\(Kz_2\)</span> 相互独立(毕竟是两个不同的称，称量结果肯定不会相互影响)，根据方差的性质，上面式子可以继续往下写： <span class="math display">\[
Var((1-K)z_1+Kz_2)=Var((1-K)z_1)+Var(Kz_2)=(1-K)^2Var(z_1)+K^2Var(z_2)
\]</span> 将上面两个方差代入得： <span class="math display">\[
(1-K)^2Var(z_1)+K^2Var(z_2)=(1-K)^2\sigma_1^2+K^2\sigma_2^2
\]</span> 也就是说： <span class="math display">\[
\sigma_{\hat{z}}^2=(1-K)^2\sigma_1^2+K^2\sigma_2^2
\]</span> 现在要求最小值，所以就是对<span class="math inline">\(K\)</span>进行求导： <span class="math display">\[
\frac{d\sigma_{\hat{z}}^2}{dK}=0
\]</span> (中间过程自行计算)<br />
最后求出<span class="math inline">\(K\)</span>的值为： <span class="math display">\[
K=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=0.2
\]</span> 把<span class="math inline">\(K\)</span>代入上面式子，其最佳估计值为： <span class="math display">\[
\hat{z}=z_1+K(z_2-z_1)=30+0.2(32-30)=30.4
\]</span> 其方差为： <span class="math display">\[
\sigma_{\hat{z}}^2=(1-0.2)^22^2+0.2^24^2=3.2
\]</span> 标准差为：<span class="math inline">\(\sqrt{3.2}=1.79\)</span><br />
这个计算过程就是数据融合。<br />
</p>
<h2 id="协方差矩阵">协方差矩阵</h2>
<p>协方差矩阵是将矩阵，协方差在一个矩阵中表示出来，表明变量空间的联动关系。比如说下面这个表格：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">名字</th>
<th style="text-align: center;">身高<span class="math inline">\((x)\)</span></th>
<th style="text-align: center;">体重<span class="math inline">\((y)\)</span></th>
<th style="text-align: center;">年龄<span class="math inline">\((z)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">179</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">33</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">187</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">31</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">175</td>
<td style="text-align: center;">71</td>
<td style="text-align: center;">28</td>
</tr>
<tr class="even">
<td style="text-align: center;">均值</td>
<td style="text-align: center;">180.3</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">30.7</td>
</tr>
</tbody>
</table>
<p>计算出变量<span class="math inline">\(x,y,z\)</span>的方差为： <span class="math display">\[
\sigma_x^2=24.89,\quad \sigma_y^2=14,\quad\sigma_z^2=4.22
\]</span> 计算协方差为： <span class="math display">\[
\begin{aligned}
\sigma_x\sigma_y &amp;= \frac{1}{3}((179-180.3)(74-75)+(187-180.3)(80-75)+(175-180.3)(71-75))\\
&amp;= 18.7=\sigma_y\sigma_x
\end{aligned}
\]</span> 同理： <span class="math display">\[
\sigma_x\sigma_z=4.4=\sigma_z\sigma_x, \quad \sigma_y\sigma_z=3.3=\sigma_z\sigma_y
\]</span> (协方差矩阵是对称矩阵。)<br />
协方差矩阵形式如下： <span class="math display">\[
 \left[
 \begin{matrix}
   \sigma_x^2 &amp; \sigma_{x,y} &amp; \sigma_{x,z} \\
   \sigma_{y,x} &amp; \sigma_y^2 &amp; \sigma_{y,z} \\
   \sigma_{z,x} &amp; \sigma_{z,y} &amp; \sigma_z^2
  \end{matrix}
  \right]
\]</span> 代入数据： <span class="math display">\[
 \left[
 \begin{matrix}
   24.89 &amp; 18.7 &amp; 4.4 \\
   18.7 &amp; 14 &amp; 3.3 \\
   4.4 &amp; 3.3 &amp; 4.22
  \end{matrix}
  \right]
\]</span> <strong>矩阵计算的方法</strong> 在写代码的时候，用矩阵计算方法计算协方差明显更容易书写，其形式如下：<br />
过渡矩阵： <span class="math display">\[
a=
 \left[
 \begin{matrix}
   x_1 &amp; y_1 &amp; z_1 \\
   x_2 &amp; y_2 &amp; z_2 \\
   x_3 &amp; y_3 &amp; z_3
 \end{matrix}
 \right]
-
\frac{1}{3}
 \left[
 \begin{matrix}
   1 &amp; 1 &amp; 1 \\
   1 &amp; 1 &amp; 1 \\
   1 &amp; 1 &amp; 1
  \end{matrix}
  \right]
   \left[
 \begin{matrix}
   x_1 &amp; y_1 &amp; z_1 \\
   x_2 &amp; y_2 &amp; z_2 \\
   x_3 &amp; y_3 &amp; z_3
  \end{matrix}
  \right]
\]</span> 协方差矩阵： <span class="math display">\[
P=\frac{1}{3}a^Ta
\]</span> 现在我们观察上面得出的那个协方差矩阵，先看对角线，前两个数字都很大（其实第三个数字不应该这么小的，但毕竟只取了三个数据，偶然性太大），表明数据波动是比较大的，说明身高体重在这个群体里影响不大；接着看其它数据，比如这个18.7，说明身高跟体重是成正比的，且相关性较大，也符合常理；然后再看看4.4，说明身高跟年龄关系不大，也对，到一定年龄身高跟年龄关系就不大了……<br />
</p>
<h2 id="状态空间方程">状态空间方程</h2>
<p>比如说对于一个弹簧阻尼系统：<img src="/images/271.png" /> 我们可以很容易写出如下微分方程(<span class="math inline">\(x\)</span>为位移)： <span class="math display">\[
m\ddot{x}+c\dot{x}+kx=F
\]</span> 状态量为： <span class="math display">\[
x_1=x;\quad x_2=\dot{x}
\]</span> 观测量为： <span class="math display">\[
z_1=x=x_1;位置\quad z_2=\dot{x}=x_2速度
\]</span> 设<span class="math inline">\(F\)</span>为输入值，等于<span class="math inline">\(u\)</span>。<br />
写成一阶微分矩阵形式如下： <span class="math display">\[
   \left[
\begin{matrix}
   \dot{x_1}  \\
   \dot{x_2} 
  \end{matrix}
  \right]
=
   \left[
\begin{matrix}
   0 &amp; 1  \\
   -\frac{k}{m} &amp; -\frac{c}{m} 
  \end{matrix}
  \right]
     \left[
\begin{matrix}
   x_1  \\
   x_2
  \end{matrix}
  \right]
+
   \left[
\begin{matrix}
   0  \\
   \frac{1}{m} 
  \end{matrix}
  \right]
u
\]</span> 观测矩阵为： <span class="math display">\[
\left[
\begin{matrix}
   z_1  \\
   z_2 
\end{matrix}
\right]
=
   \left[
\begin{matrix}
   1 &amp; 0  \\
   0 &amp; 1 
  \end{matrix}
  \right]
      \left[
\begin{matrix}
   x_1  \\
   x_2
  \end{matrix}
  \right]
\]</span> 以上两个矩阵表达式就是状态空间表达式，归纳一下可以写为： <span class="math display">\[
\dot{X}_t=AX_t+Bu_t
\]</span> <span class="math display">\[
Z_t=HX_t
\]</span> 这是一种连续的表达式，左边<span class="math inline">\(X\)</span>是对时间求导。<br />
写成离散形式为： <span class="math display">\[
X_k=AX_{k-1}+Bu_{k-1}
\]</span> <span class="math display">\[
Z_k=HX_k
\]</span> 其下标<span class="math inline">\(k.k+1,k+2...\)</span>为时间单位，即是采样。<br />
在实际生活中到处充满着不确定性，上面那个离散的状态空间表达式可以写为： <span class="math display">\[
X_k=AX_{k-1}+Bu_{k-1}+w_{k-1}
\]</span> <span class="math display">\[
Z_k=HX_k+v_k
\]</span> 其中<span class="math inline">\(w_{k-1}\)</span>为过程噪音，<span class="math inline">\(v_k\)</span>为测量噪音。<br />
根据这些如何去估计一个<span class="math inline">\(\hat{X}_k\)</span>呢？这就是卡尔曼滤波器要解决的问题。</p>
<h1 id="卡尔曼增益的数学推导">卡尔曼增益的数学推导</h1>
<p>在一开始我们用了卡尔曼增益，但却没有解释为什么这个增益是这种形式，这部分就是对它的推导。<br />
将上面那个离散情况下带噪音的状态空间方程写下来如下： <span class="math display">\[
X_k=AX_{k-1}+Bu_{k-1}+w_{k-1}
\]</span> <span class="math display">\[
Z_k=HX_k+v_k
\]</span> 两个方程的噪音部分是我们不可测的，但在自然界中我们可以把这噪声假设成正态分布(why? 只能说自然界就是这么神奇)。所以我们可以把过程噪音写成： <span class="math display">\[
P(w) \sim (0,Q)
\]</span> 这里0是期望，<span class="math inline">\(Q\)</span>是协方差矩阵。这个<span class="math inline">\(Q\)</span>可以用下面的式子计算： <span class="math display">\[
Q=E[ww^T]
\]</span> 举个例子，假如现在<span class="math inline">\(X_k\)</span>由两部分组成，即是： <span class="math display">\[
X_k=
\left[
  \begin{matrix}
   x_1  \\
   x_2
  \end{matrix}
\right]
\]</span> 则对应的过程噪音就是： <span class="math display">\[
\left[
\begin{matrix}
   w_1  \\
   w_2
  \end{matrix}
  \right]
\]</span> 这个噪音的协方差矩阵为： <span class="math display">\[
E[
\left[
\begin{matrix}
   w_1  \\
   w_2
  \end{matrix}
  \right]
\left[
\begin{matrix}
   w_1 &amp; w_2
  \end{matrix}
  \right]
]
=
\left[
\begin{matrix}
   E[w_1^2] &amp; E[w_1w_2]  \\
   E[w_2w_1] &amp; E[w_2^2]
  \end{matrix}
  \right]
\]</span> 另外，对于方差我们有： <span class="math display">\[
Var(x)=E(x^2)-E^2(x)
\]</span> 在这里噪音的期望为0，所以：<span class="math inline">\(Var(x)=E(x^2)\)</span>，上面的矩阵可以写为：<br />
<span class="math display">\[
E[
\left[
\begin{matrix}
   w_1  \\
   w_2
  \end{matrix}
  \right]
\left[
\begin{matrix}
   w_1 &amp; w_2
  \end{matrix}
  \right]
]
=
\left[
\begin{matrix}
   \sigma_{w_1}^2 &amp; \sigma_{w_1,w_2}  \\
   \sigma_{w_2,w_1} &amp; \sigma_{w_2}^2
  \end{matrix}
  \right]
\]</span> 噪音的协方差矩阵就出来了，所以这个式子： <span class="math display">\[
Q=E[ww^T]
\]</span> 是正确的。 同理，对于测量噪音<span class="math inline">\(v_k\)</span>，也是一样的： <span class="math display">\[
p(v)\sim (0,R)
\]</span> <span class="math inline">\(R\)</span>是协方差矩阵，同样用上面的方法也可以计算。<br />
在实际建模中，这两个噪音我们是无法建模出来的，我们能计算的只是下面这个东西： <span class="math display">\[
X_k^-=AX_{k-1}+Bu_{k-1} \tag{1}
\]</span> 少了噪音那项，像这种我们直接计算出来的我们称为先验估计值，表示为估计值上面带个减号。<br />
对于测量部分，我们有： <span class="math display">\[
\hat{X}_{k,mea}=H^{-1}Z_{k} \tag{2}
\]</span> 这是测量估计值。<br />
现在我们有两个结果，分别是先验估计值和测量估计值，但这两个都不具备噪声的影响，都是不准确的，然后卡尔曼滤波器的作用就出来了：通过两个不太准确的结果得出一个比较准确的结果。<br />
根据上面【数据融合】那部分的知识，后验估计值(就是我们想要的)可以写成： <span class="math display">\[
\hat{X}_k=\hat{X}_{k}^-+G(H^{-1}Z_k-\hat{X}_{k}^-)
\]</span> 这里<span class="math inline">\(G\in [0,1]\)</span>，当<span class="math inline">\(G=0\)</span>时，<span class="math inline">\(\hat{X}_k=\hat{X}_{k}^-\)</span>，表明更相信计算的结果，也就是先验估计值；如果<span class="math inline">\(G=1\)</span>，<span class="math inline">\(\hat{X}_k=H^{-1}Z_{k}\)</span>，表明更相信测量的结果。<br />
在其它地方上面的式子会写成这样： <span class="math display">\[
\hat{X}_k=\hat{X}_k^-+K_k(Z_k-H\hat{X}_{k}^-)
\]</span> 这里的<span class="math inline">\(G=K_kH\)</span>，其实一个一声，但要注意的是，这里的<span class="math inline">\(K\in[0,H^{-1}]\)</span>。<br />
现在我们要做的就是寻找这个<span class="math inline">\(K_k\)</span>，使得<span class="math inline">\(\hat{X}_k\)</span>趋近于<span class="math inline">\(X_{k}\)</span>。这里我们定义一个误差： <span class="math display">\[
e_k=X_k-\hat{X}_k
\]</span> 这里的误差<span class="math inline">\(e_k\)</span>也是一个符合正态分布的矩阵：<span class="math inline">\(P(e_{k})\sim (0,P)\)</span>(这个应该很容易理解)，依旧按照上面的方法求这个协方差矩阵： <span class="math display">\[
P=E[ee^T]=
\left[
\begin{matrix}
   \sigma_{e_1}^2 &amp; \sigma_{e_1,e_2}  \\
   \sigma_{e_2,e_1} &amp; \sigma_{e_2}^2
  \end{matrix}
  \right]
\]</span> 我们这个估计值<span class="math inline">\(\hat{X}_k\)</span>越接近于实际值，就说明这个误差的方差越小，也就说明越接近于0。现在问题就变成了我们需要选取适当的<span class="math inline">\(K_k\)</span>，使协方差矩阵的迹最小，即<span class="math inline">\(tr(P)\)</span>最小。(元素分开考虑，所以是对角线)。 <span class="math display">\[
tr(P)=\sigma_{e_1}^2+\sigma_{e_2}^2
\]</span> 现在我们首先把协方差矩阵求出来，对于误差有： <span class="math display">\[
e_k=X_k-\hat{X}_k
\]</span> 将其代入协方差矩阵的式子得： <span class="math display">\[
\begin{aligned}
P  &amp;= E[ee^T]\\
    &amp;=E[(X_k-\hat{X}_k)(X_k-\hat{X}_{k})^T]
\end{aligned}
\]</span> 将 <span class="math display">\[
\hat{X}_k=\hat{X}_k^-+K_k(Z_k-H\hat{X}_{k}^-)
\]</span> <span class="math display">\[
Z_k=HX_k+v_k
\]</span> 代入得： <span class="math display">\[
\begin{aligned}
X_k-\hat{X}_k &amp;= (X_k-\hat{X}_{k}^-)-K_kH(X_k-\hat{X}_{k}^-)-K_kv_k \\
&amp;=(I-K_kH)(X_k-\hat{X}_{k}^-)-K_kv_k
\end{aligned}
\]</span> 定义先验误差 <span class="math inline">\(e_k^-=(X_k-\hat{X}_{k}^-)\)</span>。<br />
所以上面的协方差矩阵可以写为： <span class="math display">\[
\begin{aligned}
P_k  &amp;= E[ee^T]\\
    &amp;= E[(X_k-\hat{X}_k)(X_k-\hat{X}_{k})^T]\\
    &amp;= E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\
    &amp;= E[(I-K_kH)e_k^-{e_k^-}^T(I-K_kH)^T]-E[(I-K_kH)e_k^-v_k^TK_k^T]
        -E[K_kv_k{e_k^-}^T(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]
\end{aligned}
\]</span> 由于<span class="math inline">\((I-K_kH)\)</span>是常数，且对于独立的<span class="math inline">\(A,B\)</span>，有<span class="math inline">\(E(AB)=E(A)E(B)\)</span>，<span class="math inline">\(E(e_K^-)=E(v_k^T)=0\)</span>，所以上式的中间两项为0。上式可以继续化简： <span class="math display">\[
\begin{aligned}
P_k  &amp;= E[ee^T]\\
    &amp;= E[(X_k-\hat{X}_k)(X_k-\hat{X}_{k})^T]\\
    &amp;= E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\
    &amp;= E[(I-K_kH)e_k^-{e_k^-}^T(I-K_kH)^T]-E[(I-K_kH)e_k^-v_k^TK_k^T]
        -E[K_kv_k{e_k^-}^T(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\
    &amp;= (I-K_kH)E[(e_k^-{e_k^-}^T)](I-K_kH)^T+K_kE[v_kv_k^T]K_k^T
\end{aligned}
\]</span> 由于<span class="math inline">\(E[(e_k^-{e_k^-}^T)]\)</span>为先验误差的协方差矩阵<span class="math inline">\(P_k^-\)</span>，<span class="math inline">\(R=E[v_kv_k^T]\)</span>上面等式就可以继续化简： <span class="math display">\[
\begin{aligned}
P_k  &amp;= E[ee^T]\\
    &amp;= E[(X_k-\hat{X}_k)(X_k-\hat{X}_{k})^T]\\
    &amp;= E[[(I-K_kH)e_k^--K_kv_k][(I-K_kH)e_k^--K_kv_k]^T]\\
    &amp;= E[(I-K_kH)e_k^-{e_k^-}^T(I-K_kH)^T]-E[(I-K_kH)e_k^-v_k^TK_k^T]
        -E[K_kv_k{e_k^-}^T(I-K_kH)^T]+E[K_kv_kv_k^TK_k^T]\\
    &amp;= (I-K_kH)E[(e_k^-{e_k^-}^T)](I-K_kH)^T+K_kE[v_kv_k^T]K_k^T\\
    &amp;=(P_k^--K_kHP_k^-)(I-H^TK_k^T)+K_kRK_k^T\\
    &amp;=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T
\end{aligned}
\]</span> 现在就求出这个协方差矩阵了，接下来是求迹。我们看右边第三项，对其转置： <span class="math display">\[
((P_k^-H^T)K_k^T)^T=K_k(P_k^-H^T)^T=K_kH{P_k^-}^T
\]</span> 也就是说，第三项的转置等于第二项，所以第三项的迹与第二项相同。所以协方差矩阵的迹为： <span class="math display">\[
tr(P_k)=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kRK_k^T)
\]</span> 现在要求迹最小时对应的<span class="math inline">\(K_k\)</span>，即是求导等于0。<br />
这里先说个东西： <span class="math display">\[
\frac{dtr(AB)}{dA}=B^T
\]</span> <span class="math display">\[
\frac{d(ABA^T)}{dA}=2AB
\]</span> (这个自己验证)<br />
所以： <span class="math display">\[
\frac{dtr(P_k)}{dK_k}=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR=0
\]</span> 即： <span class="math display">\[
-P_k^-H^T+K_k(HP_k^-H^T+R)=0
\]</span> <span class="math display">\[
K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}
\]</span> 这就是卡尔曼滤波器最核心的公式，分析一下，当<span class="math inline">\(R\)</span>特别大时，即测量噪声特别大时，<span class="math inline">\(K_k\)</span>就趋近于0，此时估计值<span class="math inline">\(\hat{X}_k\)</span>就等于先验估计<span class="math inline">\(\hat{X}_{k}^-\)</span>，我们就更愿意相信计算的先验估计；当<span class="math inline">\(R\)</span>很小时，<span class="math inline">\(K_k\)</span>就趋近于<span class="math inline">\(H^{-1}\)</span>，估计值就等于测量估计。</p>
<h1 id="误差协方差矩阵">误差协方差矩阵</h1>
<p>上面我们得出了卡尔曼增益的表达式： <span class="math display">\[
K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}
\]</span> 在这个表达式中<span class="math inline">\(P_k^-\)</span>我们还不知道，这部分就是对这个的推导。<br />
我们已知： <span class="math display">\[
P_k^-=E[e_k^--{e_k^-}^T]
\]</span> <span class="math display">\[
\begin{aligned}
e_k^- &amp;=X_k-\hat{X}_k^-\\
    &amp;= AX_{k-1}+Bu_{k-1}+w_{k-1}-A\hat{X}_{k-1}-Bu_{k-1}\\
    &amp;= A(X_{k-1}-\hat{X}_{k-1})+w_{k-1}\\
    &amp;= Ae_{k-1}+w_{k-1}
\end{aligned}
\]</span> 代入上面的协方差矩阵： <span class="math display">\[
\begin{aligned}
P_k^- &amp;=E[e_k^--{e_k^-}^T]\\
    &amp;= E[(Ae_{k-1}+w_{k-1})((Ae_{k-1})^T+(w_{k-1})^T)]\\
    &amp;= E[Ae_{k-1}e_{k-1}^TA^T]+E[Ae_{k-1}w_{k-1}^T]+E[w_{k-1}e_{k-1}^TA^T]+E[w_{k-1}w_{k-1}^T]
\end{aligned}
\]</span> 这里，由于<span class="math inline">\(e_{k-1}\)</span>和<span class="math inline">\(w_{k-1}\)</span>是相互独立的（<span class="math inline">\(e_{k-1}\)</span>与<span class="math inline">\(w_{k-1}\)</span>无关而与<span class="math inline">\(w_{k-2}\)</span>有关），所以相乘的期望等于期望的相乘，都等于0，上面式子中间两项等于0，可以写为： <span class="math display">\[
\begin{aligned}
P_k^- &amp;=E[e_k^--{e_k^-}^T]\\
    &amp;= E[(Ae_{k-1}+w_{k-1})((Ae_{k-1})^T+(w_{k-1})^T)]\\
    &amp;= E[Ae_{k-1}e_{k-1}^TA^T]+E[Ae_{k-1}w_{k-1}^T]+E[w_{k-1}e_{k-1}^TA^T]+E[w_{k-1}w_{k-1}^T]\\
    &amp;= AE[e_{k-1}e_{k-1}^T]+E[w_{k-1}w_{k-1}^T]\\
    &amp;= AP_{k-1}A^T+Q
\end{aligned}
\]</span> 至此，就可以用卡尔曼滤波器来估计状态变量的值了。这个过程分为两步：</p>
<blockquote>
<p><strong>预测：</strong><br />
 计算先验：<span class="math display">\[\hat{X}_k^-=A\hat{X}_{k-1}+Bu_{k-1} \tag{1}\]</span><br />
 先验误差协方差：<span class="math display">\[P_k^-=AP_{k-1}A^T+Q \tag{2}\]</span></p>
</blockquote>
<blockquote>
<p><strong>校正：</strong><br />
 卡尔曼增益： <span class="math display">\[
K_k=\frac{P_k^-H^T}{HP_k^-H^T+R} \tag{3}
\]</span>  后验估计： <span class="math display">\[
\hat{X}_k=\hat{X}_{k}^-+K_k(Z_k-H\hat{X}_k^-) \tag{4}
\]</span></p>
</blockquote>
<p>由于在预测中用了上一次的误差协方差，所以要更新这个参数，在上一部分我们得出了： <span class="math display">\[
P_k=P_k^--K_kHP_k^--P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T
\]</span> 将算出的<span class="math inline">\(K_k\)</span>代入得： <span class="math display">\[
P_k=P_k^--K_kHP_k^-=(I-K_kH)P_k^- \tag{5}
\]</span> 上面公式(1) -- (5)就是卡尔曼滤波器最重要的5个公式了，在最开始的时候我们要初始化<span class="math inline">\(\hat{X}_0\)</span> 和 <span class="math inline">\(P_{0}\)</span>。</p>

    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>
      
    </div>


    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/19.html" rel="prev" title="【ML-2020/21】Generative Adversarial Network (GAN) --- Part-2 Conditional GAN">
      <i class="fa fa-chevron-left"></i> 【ML-2020/21】Generative Adversarial Network (GAN) --- Part-2 Conditional GAN
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/21.html" rel="next" title="假设性检测 (t-test, z-test)">
      假设性检测 (t-test, z-test) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">写在前面的说明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">引入 —— 递归算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">数据融合，协方差矩阵，状态空间方程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88"><span class="nav-number">3.1.</span> <span class="nav-text">数据融合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.</span> <span class="nav-text">协方差矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%96%B9%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">状态空间方程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%A1%E5%B0%94%E6%9B%BC%E5%A2%9E%E7%9B%8A%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.</span> <span class="nav-text">卡尔曼增益的数学推导</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AF%E5%B7%AE%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5"><span class="nav-number">5.</span> <span class="nav-text">误差协方差矩阵</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="super_wzl"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">super_wzl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">super_wzl</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-611ffbcfffca5ad1" async="async"></script>
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JbTCzSGo7EeV9tTlVHeWHuWx-MdYXbMMI',
      appKey     : '3yO7D6U6pVQy4RVNcsKIxy4m',
      placeholder: "来唠两句吗？",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
