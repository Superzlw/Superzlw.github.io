<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Hello-测试"><a href="#Hello-测试" class="headerlink" title="Hello 测试"></a>Hello 测试</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test_first_blog</title>
    <url>/2021/08/03/test-first-blog/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>学习记录_Computer Vision1_作业1_(1) Bayer Interpolation</title>
    <url>/2021/08/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Computer-Vision1-%E4%BD%9C%E4%B8%9A1-1-Bayer-Interpolation/</url>
    <content><![CDATA[<p>这次作业需要记录的有三道题，包括：</p>
<ol>
<li>Bayer Interpolation</li>
<li>Projective Transformation</li>
<li>Image Filtering and Edge Detection</li>
</ol>
<h2 id="（1）Bayer-Interpolation"><a href="#（1）Bayer-Interpolation" class="headerlink" title="（1）Bayer Interpolation"></a>（1）Bayer Interpolation</h2><span id="more"></span>
<p>作业要求：<br>    <img src="https://img-blog.csdnimg.cn/20201214062515791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>简单来说，即是给出一张Bayer图片，将其转化为RGB图。<br>作业给出的图片如下：<img src="https://img-blog.csdnimg.cn/20201214185058357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>这里先对Bayer图进行简要说明。</strong><br>与一般RGB图不同，Bayer图的像素分布如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201214063319235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在Bayer图中，每个像素点都是由单一颜色所控制，而且绿色所占的比例是其他两种颜色的两倍，所以整张图片看起来会偏绿，我们所要做的就是通过插值将每个像素点的其他两种颜色算出来。</p>
<h6 id="步骤1："><a href="#步骤1：" class="headerlink" title="步骤1："></a>步骤1：</h6><p>将Bayer数据分成RGB通道，以便每个颜色通道仅保留Bayer模式给定的相应值，而缺失值则用零填充。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">separatechannels</span>(<span class="params">bayerdata</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Separate bayer data into RGB channels so that</span></span><br><span class="line"><span class="string">    each color channel retains only the respective</span></span><br><span class="line"><span class="string">    values given by the bayer pattern and missing values</span></span><br><span class="line"><span class="string">    are filled with zero</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        Numpy array containing bayer data (H,W)</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        red, green, and blue channel as numpy array (H,W)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    H, W = bayerdata.shape</span><br><span class="line">    r = np.zeros((H, W))</span><br><span class="line">    g = np.zeros((H, W))</span><br><span class="line">    b = np.zeros((H, W))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">            <span class="keyword">if</span>((i + j) % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">                g[i][j] = bayerdata[i][j]</span><br><span class="line">            <span class="keyword">elif</span>(i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> (i + j) % <span class="number">2</span> != <span class="number">0</span>):</span><br><span class="line">                r[i][j] = bayerdata[i][j]</span><br><span class="line">            <span class="keyword">elif</span>(i % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> (i + j) % <span class="number">2</span> != <span class="number">0</span>):</span><br><span class="line">                b[i][j] = bayerdata[i][j]</span><br><span class="line">    <span class="keyword">return</span> r, g, b</span><br></pre></td></tr></table></figure>
<h6 id="步骤2："><a href="#步骤2：" class="headerlink" title="步骤2："></a>步骤2：</h6><p>将单独的通道组合成图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assembleimage</span>(<span class="params">r, g, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Assemble separate channels into image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        red, green, blue color channels as numpy array (H,W)</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        Image as numpy array (H,W,3)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    H, W = r.shape</span><br><span class="line">    imgData = np.zeros((H, W, <span class="number">3</span>))</span><br><span class="line">    imgData[:,:,<span class="number">0</span>] = r[:,:]</span><br><span class="line">    imgData[:,:,<span class="number">1</span>] = g[:,:]</span><br><span class="line">    imgData[:,:,<span class="number">2</span>] = b[:,:]</span><br><span class="line">    <span class="keyword">return</span> imgData</span><br></pre></td></tr></table></figure>
<p>结果如下图：<br><img src="https://img-blog.csdnimg.cn/20201218023313111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h6 id="步骤3："><a href="#步骤3：" class="headerlink" title="步骤3："></a>步骤3：</h6><p>通过使用双线性插值对Bayer模式中的缺失值进行插值。<br>双线性插值，简单来说就是通过邻近4个点平均出中间点的数值。<br>其实主要就是计算R,G,B三通道的卷积核。说之前先解释一个函数：scipy.ndimage.filters.convolve，（python的各种库里有非常多用于卷积的函数，改天做个对比总结）。</p>
<p><strong>scipy.ndimage.filters.convolve：</strong><br>(这里给个 <a href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.filters.convolve.html/">链接</a>，说得很详细了已经)</p>
<p><em>scipy.ndimage.filters.convolve(input, weights, output=None,<br> mode=’reflect’, cval=0.0, origin=0)</em><br>input: 待卷积的图片<br> weight: 卷积核<br> output:（这个未知，好像一直没用过这个，（待定））<br> mode: 边缘处理，有5种（关于各个边缘模式的选用现在还未理解）</p>
<pre><code>    ‘reflect’ (d c b a | a b c d | d c b a)
    ‘constant’ (k k k k | a b c d | k k k k)
    ‘nearest’ (a a a a | a b c d | d d d d)
    ‘mirror’ (d c b | a b c d | c b a)
    ‘wrap’ (a b c d | a b c d | a b c d)
</code></pre>
<p>cval：默认是0，当mode取constant时有效，这个的取值既是边缘外补什么值<br>origin：默认0，应该是控制weight在input上的位置的，目前也还没用过</p>
<p>这里有一个要特别注意的是，<strong>卷积核不是直接对应相乘然后相加，而是要先翻转</strong>，举个例子，比如一个卷积核设为：<br><img src="https://img-blog.csdnimg.cn/20201218094517319.png#pic_center" alt="在这里插入图片描述"><br>但实际上并不是上面这个与图片卷积，而是下面这个卷积核：<br><img src="https://img-blog.csdnimg.cn/20201218094610325.png#pic_center" alt="在这里插入图片描述"><br>这点在初始化卷积核的时候要注意（不过目前遇到的好像都是中心对称的）</p>
<p>回到题里，G通道对应的矩阵如下图：<br><img src="https://img-blog.csdnimg.cn/20201218104911416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>按照双线性插值，很容易能得到卷积核四个角的值，又由于应该把原本的像素值保留下来，再根据边界插值条件，就可以确定出通道G的卷积核，其他两个通道同理可各自获得卷积核值。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interpolate</span>(<span class="params">r, g, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Interpolate missing values in the bayer pattern</span></span><br><span class="line"><span class="string">    by using bilinear interpolation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        red, green, blue color channels as numpy array (H,W)</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        Interpolated image as numpy array (H,W,3)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r_weight = np.array([[<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>],[<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>],[<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>]])</span><br><span class="line">    g_weight = np.array([[<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0</span>],[<span class="number">0.25</span>,<span class="number">1</span>,<span class="number">0.25</span>],[<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0</span>]])</span><br><span class="line">    b_weight = np.array([[<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>],[<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>],[<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>]])</span><br><span class="line"></span><br><span class="line">    new_r = convolve(r, r_weight, mode=<span class="string">&#x27;mirror&#x27;</span>)</span><br><span class="line">    new_g = convolve(g, g_weight, mode=<span class="string">&#x27;mirror&#x27;</span>)</span><br><span class="line">    new_b = convolve(b, b_weight, mode=<span class="string">&#x27;mirror&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(new_g)</span></span><br><span class="line">    <span class="comment">#print(new_r)</span></span><br><span class="line">    <span class="comment">#print(new_b)</span></span><br><span class="line"></span><br><span class="line">    H, W = new_r.shape</span><br><span class="line">    new_img = np.zeros((H, W, <span class="number">3</span>))</span><br><span class="line">    new_img[:,:,<span class="number">0</span>] = new_r[:,:]</span><br><span class="line">    new_img[:,:,<span class="number">1</span>] = new_g[:,:]</span><br><span class="line">    new_img[:,:,<span class="number">2</span>] = new_b[:,:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> new_img</span><br></pre></td></tr></table></figure>
<p>最后就是对以上函数的调用，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">problem2</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Example code implementing the steps in Problem 2</span></span><br><span class="line"><span class="string">    Note: uses display_image() from Problem 1&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    data = loaddata(<span class="string">&quot;data/bayerdata.npy&quot;</span>)</span><br><span class="line">    r, g, b = separatechannels(data)</span><br><span class="line"></span><br><span class="line">    img = assembleimage(r, g, b)</span><br><span class="line">    display_image(img)</span><br><span class="line"></span><br><span class="line">    img_interpolated = interpolate(r, g, b)</span><br><span class="line">    display_image(img_interpolated)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#problem1()</span></span><br><span class="line">    problem2()</span><br><span class="line">    <span class="comment">#problem3()</span></span><br><span class="line">    <span class="comment">#problem4()   </span></span><br></pre></td></tr></table></figure>
<p>最后得到的图片如下：<br><img src="https://img-blog.csdnimg.cn/20201218115816873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzUwMTg4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>本次作业及该篇学习记录遗留下的问题：</p>
<ol>
<li>卷积的mode是“mirror”，原因未明；</li>
<li>要对python里各个库的卷积函数进行总结；</li>
<li>这次作业用到的卷积函数的output以及origin参数</li>
</ol>
]]></content>
  </entry>
</search>
